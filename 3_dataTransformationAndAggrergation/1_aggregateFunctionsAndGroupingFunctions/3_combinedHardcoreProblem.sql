		-- 3 Hardcore Combined Problem

-- 		The company requires a multi-level analytical report for the year 2023. This report needs
-- to consolidate employee information, their project contributions, sales performance, and
-- specific departmental metrics. The report must be structured with employee-level details,
-- department-level summaries (including for employees not assigned to any department),
-- and a grand total summary.

-- Report Output Structure
-- The final report should contain the following columns. The content of these columns
-- will vary based on the reporting level (Employee Detail, Department Summary, Grand
-- Total).

-- 1. reportingLevel (TEXT): Indicates the level of aggregation: ’Employee Detail’,
-- ’Department Summary’, or ’Grand Total’.
-- 2. departmentName (TEXT): The name of the department. For employees without a
-- department, display ’No Department Assigned’. For the grand total row, display
-- ’Overall Summary’.
-- 3. employeeFullName (TEXT): Concatenation of firstName and lastName. NULL
-- for summary rows.
-- 4. employeeHireYear (INTEGER): The year the employee was hired. NULL for
-- summary rows.
-- 5. skillsList (TEXT): A comma-separated string of the employee’s skills, sorted
-- alphabetically. If no skills are listed for an employee, this should be ’No Skills
-- Listed’. NULL for summary rows.
-- 6. projectsParticipated (TEXT): A comma-separated string of distinct project
-- names the employee worked on, sorted alphabetically by project name. If an em-
-- ployee worked on no projects, display ’None’. NULL for summary rows.
-- 7. totalHoursOnProjects (NUMERIC): Total hours worked by the employee on all
-- projects. This value should be summed up for Department Summary and Grand
-- Total levels.
-- 8. totalRevenueGenerated2023 (NUMERIC): Total revenue (calculated as SUM(Sales.quantity
-- * Products.listPrice)) generated by the employee from sales made in the year
-- 2023. This value should be summed up for Department Summary and Grand Total
-- levels. Employees with no sales in 2023 should show 0.
-- 9. salesQtyVsSatisfactionCorr2023 (NUMERIC): For each employee, the Pearson
-- correlation coefficient between Sales.quantity and the customerSatisfaction
-- score (extracted from Sales.notes ->> ’customerSatisfaction’ as an integer)
-- for sales made in 2023. This should be NULL if the employee has fewer than two
-- sales in 2023 with valid customerSatisfaction scores, or if they made no sales.
-- NULL for summary rows.
-- 10. medianSalaryInDepartment (NUMERIC): The median salary for the department,
-- calculated using PERCENTILE CONT(0.5). This should only appear on ’Department
-- Summary’ rows and be NULL otherwise. For the ’No Department Assigned’ group,
-- it’s the median salary of those employees.
-- 10. medianSalaryInDepartment (NUMERIC): The median salary for the department,
-- calculated using PERCENTILE CONT(0.5). This should only appear on ’Department
-- Summary’ rows and be NULL otherwise. For the ’No Department Assigned’ group,
-- it’s the median salary of those employees.
-- SELECT * FROM medianSalaryInDepartment;
WITH EmployeeSkills AS (
	SELECT 
		employeeId,
		COALESCE(STRING_AGG(u_skills, ', ' ORDER BY u_skills), 'No skills listed') s_skills 
	FROM (
		SELECT employeeId, UNNEST(skills) u_skills
		FROM data_transformation_and_aggregation.employees
	) sq GROUP BY employeeId
), ProjectedEmployee AS (
	SELECT 
		employeeId, 
		COALESCE(STRING_AGG(projectname, ', ' ORDER BY projectname), 'None') projects,
		SUM(hoursWorked) totalHoursOnProjects
	FROM data_transformation_and_aggregation.employees
	NATURAL JOIN data_transformation_and_aggregation.employeeprojects
	NATURAL JOIN data_transformation_and_aggregation.projects
	GROUP BY employeeId
), SellingEmployees AS (
	SELECT 
		e.employeeId,
		SUM(quantity * listPrice) totalRevenueGenerated2023
	FROM data_transformation_and_aggregation.employees e
	JOIN data_transformation_and_aggregation.sales s 
		ON EXTRACT(YEAR FROM s.saleDate) = 2023 AND s.employeeId = e.employeeId
	NATURAL JOIN data_transformation_and_aggregation.products p
	GROUP BY e.employeeId
), SatisfactionPurchasing AS (
	SELECT employeeId, CORR(customerSatisfaction, quantity) quantityForSatisfaction FROM (
		SELECT 
			e.employeeId,
			quantity,
			(notes ->> 'customerSatisfaction')::NUMERIC customerSatisfaction
		FROM data_transformation_and_aggregation.employees e
		JOIN data_transformation_and_aggregation.sales s 
			ON EXTRACT(YEAR FROM s.saleDate) = 2023 AND s.employeeId = e.employeeId
		NATURAL JOIN data_transformation_and_aggregation.products p
	) sq GROUP BY employeeId
), medianSalaryInDepartment AS (
	SELECT 
		d.departmentId,
		PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY salary) medianSalary
	FROM data_transformation_and_aggregation.employees e
	LEFT JOIN data_transformation_and_aggregation.departments d
	ON e.departmentId = d.departmentId
	GROUP BY d.departmentId
), departmentPerformanceOverviewJson AS (
	SELECT e.departmentId, 
		JSONB_AGG(
			JSON_BUILD_OBJECT(
				'employeeId', e.employeeId,
				'performanceScore', performanceScore)
		) departmentalPerformances
	FROM data_transformation_and_aggregation.employees e
	LEFT JOIN data_transformation_and_aggregation.departments d
	ON e.departmentId = d.departmentId
	WHERE performanceScore IS NOT NULL
	GROUP BY e.departmentId
)
-- SELECT * FROM departmentPerformanceOverviewJson;

-- 11. departmentPerformanceOverviewJson (JSONB): A JSON array of objects. Each
-- object represents an employee within that department (or ’No Department As-
-- signed’ group) and contains their employeeId and performanceScore. Only in-
-- clude employees with a non-NULL performanceScore. The array should be ordered
-- by performanceScore in descending order. This should only appear on ’Depart-
-- ment Summary’ rows and be NULL otherwise. If a department has no employees
-- with performance scores, it should be an empty JSON array [].

SELECT
	reportingLevel,
	CASE reportingLevel
		WHEN 'Employee Detail' THEN COALESCE(dto.departmentName, 'No Department Assigned')
		WHEN 'Department Summary' THEN CONCAT(COALESCE(dto.departmentName, 'No Department Assigned'))
		ELSE 'Overall Summary'
	END departmentName,
	eo.firstName || ' ' || eo.lastName employeeFullName,
	eo.hireDate,
	(SELECT s_skills FROM EmployeeSkills eo WHERE eo.employeeId = summary.employeeId) skills,
	COALESCE(projects, 'None') projects,
	COALESCE(totalHoursOnProjects, 0) totalHoursOnProjects,
	COALESCE(totalRevenueGenerated2023, 0) totalRevenueGenerated2023,
	quantityForSatisfaction,
	CASE
		WHEN eo.firstName IS NULL AND reportingLevel = 'Department Summary' THEN medianSalary
		ELSE NULL
	END medianSalary,
	CASE
		WHEN eo.firstName IS NULL AND reportingLevel = 'Department Summary' THEN departmentalPerformances
		ELSE NULL
	END departmentalPerformances,
	summary.salesPerformance
FROM (
	SELECT 
		CASE
			WHEN GROUPING(departmentId) = 0 AND GROUPING(employeeId) = 0
				THEN CONCAT('Employee Detail')
			WHEN GROUPING(departmentId) = 0 AND GROUPING(employeeId) = 1
				THEN 'Department Summary'
			ELSE 'Grand Total'
		END reportingLevel,
		ROUND(AVG(performanceScore), 2) salesPerformance,
		departmentId, employeeId
	FROM data_transformation_and_aggregation.employees
	GROUP BY ROLLUP(departmentId, employeeId)
	ORDER BY GROUPING(departmentId), GROUPING(employeeId)
) summary
LEFT JOIN data_transformation_and_aggregation.employees eo USING(employeeId)
LEFT JOIN data_transformation_and_aggregation.departments dto
	ON summary.departmentId = dto.departmentId
LEFT JOIN ProjectedEmployee USING(employeeId)
LEFT JOIN SellingEmployees USING(employeeId)
LEFT JOIN SatisfactionPurchasing USING(employeeId)
LEFT JOIN medianSalaryInDepartment msid 
	ON summary.departmentId IS NOT DISTINCT FROM msid.departmentId
LEFT JOIN departmentPerformanceOverviewJson dpoj
	ON summary.departmentId IS NOT DISTINCT FROM dpoj.departmentId;

-- Requirements
-- • Utilize Common Table Expressions (CTEs) to structure your query logically.
-- • Employ STRING AGG for skillsList and projectsParticipated.
-- • Employ PERCENTILE CONT for medianSalaryInDepartment.
-- • Employ JSON AGG along with JSON BUILD OBJECT for departmentPerformanceOverviewJson,
-- using the FILTER clause where appropriate.
-- • Employ CORR for salesQtyVsSatisfactionCorr2023. Handle JSON parsing (->>)
-- and type casting for customerSatisfaction.
-- • Use GROUPING SETS to generate the employee-level details, department-level sum-
-- maries, and the grand total in a single query.
-- • Make use of COALESCE, CASE expressions (especially with GROUPING()), date func-
-- tions (EXTRACT), string functions (UNNEST for skills array, || for concatenation),
-- and appropriate JOIN types.
-- • All monetary values should be to two decimal places where applicable.
-- • The final output should be ordered by departmentName (with ’No Department As-
-- signed’ first, then alphabetically, then ’Overall Summary’ last), then by reportingLevel
-- (Employee Detail, then Department Summary), and then by employeeFullName for
-- detail rows.